# Output Formats Reference

Comprehensive guide to all output formats generated by PinmapGen, including structure, usage patterns, and customization options.

---

## Overview

PinmapGen generates **five distinct output formats** from a single CSV netlist:

| Format | File Path | Primary Use Case | Target Audience |
|--------|-----------|------------------|-----------------|
| **JSON** | `pinmaps/pinmap.json` | Machine-readable metadata, tooling integration | Build systems, automation scripts |
| **MicroPython** | `firmware/micropython/pinmap_micropython.py` | Embedded Python development | MicroPython developers |
| **Arduino** | `firmware/include/pinmap_arduino.h` | C/C++ embedded development | Arduino/PlatformIO developers |
| **Markdown** | `firmware/docs/PINOUT.md` | Human-readable documentation | Hardware engineers, documentation |  
| **Mermaid** | `firmware/docs/pinout.mmd` | Visual diagrams and schematics | System architects, presentations |

All formats are generated simultaneously and stay synchronized automatically.

---

## JSON Format

**File:** `pinmaps/pinmap.json`

### Structure

```json
{
  "metadata": {
    "generated_at": "2024-01-15T10:30:00Z",
    "generator_version": "0.1.0", 
    "source_file": "hardware/exports/sample_netlist.csv",
    "mcu_reference": "U1"
  },
  "mcu": {
    "type": "rp2040",
    "package": "QFN-56", 
    "pin_count": 56,
    "capabilities": {
      "gpio_pins": 30,
      "adc_pins": 3,
      "pwm_channels": 16,
      "uart_interfaces": 2,
      "i2c_interfaces": 2, 
      "spi_interfaces": 2
    }
  },
  "pins": [
    {
      "physical_pin": 20,
      "logical_pin": "GP15",
      "net_name": "LED_STATUS",
      "role": "output",
      "capabilities": ["gpio", "pwm"],
      "validation": {
        "warnings": [],
        "suggestions": ["Consider PWM for LED brightness control"]
      }
    }
  ],
  "validation_summary": {
    "total_pins": 8,
    "warnings": 2,
    "errors": 0,
    "differential_pairs": 1
  }
}
```

### Usage Patterns

**Build system integration:**
```python
# build_firmware.py
import json

def validate_pin_assignments():
    with open('pinmaps/pinmap.json', 'r') as f:
        pinmap = json.load(f)
    
    # Check for validation errors
    if pinmap['validation_summary']['errors'] > 0:
        print("❌ Pin assignment errors detected")
        return False
        
    # Verify required pins are present
    required_pins = ['LED_STATUS', 'I2C_SDA', 'I2C_SCL']
    assigned_pins = [pin['net_name'] for pin in pinmap['pins']]
    
    missing = set(required_pins) - set(assigned_pins)
    if missing:
        print(f"❌ Missing required pins: {missing}")
        return False
        
    return True
```

**Automated testing:**
```javascript
// hardware_test.js (Node.js test framework)
const pinmap = require('./pinmaps/pinmap.json');

describe('Hardware Pin Assignment', () => {
  test('All GPIO pins assigned', () => {
    const gpioPins = pinmap.pins.filter(pin => pin.capabilities.includes('gpio'));
    expect(gpioPins.length).toBeGreaterThan(0);
  });
  
  test('No validation errors', () => {
    expect(pinmap.validation_summary.errors).toBe(0);
  });
  
  test('USB differential pair present', () => {
    const usbPins = pinmap.pins.filter(pin => pin.net_name.includes('USB_'));
    expect(usbPins.length).toBe(2); // USB_DP and USB_DM
  });
});
```

**Documentation generation:**
```python
# Generate hardware specification docs
def generate_hardware_spec():
    with open('pinmaps/pinmap.json', 'r') as f:
        pinmap = json.load(f)
    
    spec = f"""
    # Hardware Specification
    
    **MCU:** {pinmap['mcu']['type'].upper()} ({pinmap['mcu']['package']})
    **GPIO Pins Used:** {len(pinmap['pins'])} of {pinmap['mcu']['capabilities']['gpio_pins']}
    **Generated:** {pinmap['metadata']['generated_at']}
    
    ## Pin Summary
    """
    
    for pin in sorted(pinmap['pins'], key=lambda x: x['physical_pin']):
        spec += f"- **{pin['net_name']}:** {pin['logical_pin']} (Pin {pin['physical_pin']}, {pin['role']})\n"
    
    return spec
```

---

## MicroPython Format

**File:** `firmware/micropython/pinmap_micropython.py`

### Structure

```python
"""
Pin mapping constants for MicroPython
Generated from: hardware/exports/sample_netlist.csv
MCU: RP2040 (Reference: U1)
Generated: 2024-01-15T10:30:00Z

⚠️  AUTOMATICALLY GENERATED - DO NOT EDIT MANUALLY
    Regenerate using: python -m tools.pinmapgen.cli
"""

# GPIO Pin Assignments
LED_STATUS = 15    # GP15 - Physical pin 20
LED_ERROR = 16     # GP16 - Physical pin 21  
BUTTON_INPUT = 17  # GP17 - Physical pin 22

# Communication Interfaces  
I2C_SDA = 4       # GP4 - Physical pin 6
I2C_SCL = 5       # GP5 - Physical pin 7
UART_TX = 0       # GP0 - Physical pin 1
UART_RX = 1       # GP1 - Physical pin 2

# USB Interface (Hardware-managed)
USB_DP = 24       # GP24 - Physical pin 35
USB_DM = 25       # GP25 - Physical pin 34

# Pin validation warnings:
# - LED_STATUS (GP15): Consider PWM for brightness control
# - I2C pins (GP4/GP5): Verify pull-up resistors on schematic

# Usage examples:
# from machine import Pin, I2C
# from pinmap_micropython import *
# 
# led = Pin(LED_STATUS, Pin.OUT)
# button = Pin(BUTTON_INPUT, Pin.IN, Pin.PULL_UP)
# i2c = I2C(0, sda=Pin(I2C_SDA), scl=Pin(I2C_SCL))
```

### Usage Patterns

**Basic GPIO control:**
```python
# main.py - MicroPython application
from machine import Pin, Timer
from pinmap_micropython import *

# Initialize hardware using generated constants
status_led = Pin(LED_STATUS, Pin.OUT)
error_led = Pin(LED_ERROR, Pin.OUT) 
button = Pin(BUTTON_INPUT, Pin.IN, Pin.PULL_UP)

# Event-driven programming
def button_handler(pin):
    if not pin.value():  # Button pressed (active low)
        status_led.toggle()
        print(f"Button pressed, LED now: {'ON' if status_led.value() else 'OFF'}")

button.irq(trigger=Pin.IRQ_FALLING, handler=button_handler)

# Periodic status indication
def heartbeat(timer):
    status_led.toggle()

heartbeat_timer = Timer()
heartbeat_timer.init(period=1000, mode=Timer.PERIODIC, callback=heartbeat)
```

**I2C sensor interfacing:**
```python
# sensors.py
from machine import Pin, I2C
import time
from pinmap_micropython import I2C_SDA, I2C_SCL

class SensorManager:
    def __init__(self):
        # Use generated pin constants for I2C setup
        self.i2c = I2C(0, sda=Pin(I2C_SDA), scl=Pin(I2C_SCL), freq=100000)
        self.devices = self.scan_devices()
        
    def scan_devices(self):
        """Scan for I2C devices and return addresses"""
        devices = self.i2c.scan()
        print(f"Found I2C devices: {[hex(addr) for addr in devices]}")
        return devices
        
    def read_temperature(self, addr=0x48):
        """Read from TMP75 temperature sensor"""
        if addr not in self.devices:
            raise ValueError(f"Device {hex(addr)} not found")
            
        data = self.i2c.readfrom_mem(addr, 0x00, 2)
        temp_raw = (data[0] << 8) | data[1]
        temp_c = temp_raw * 0.0625  # TMP75 resolution
        return temp_c

# Usage
sensors = SensorManager()
while True:
    try:
        temp = sensors.read_temperature()
        print(f"Temperature: {temp:.1f}°C")
    except Exception as e:
        print(f"Sensor error: {e}")
    time.sleep(5)
```

**Modular hardware abstraction:**
```python
# hardware.py - Hardware abstraction layer
from machine import Pin, PWM, ADC, I2C, SPI
from pinmap_micropython import *

class HardwarePlatform:
    """Hardware abstraction using PinmapGen constants"""
    
    def __init__(self):
        # LEDs with PWM support for brightness
        self.status_led = PWM(Pin(LED_STATUS))
        self.error_led = PWM(Pin(LED_ERROR))
        self.status_led.freq(1000)
        self.error_led.freq(1000)
        
        # Digital inputs
        self.button = Pin(BUTTON_INPUT, Pin.IN, Pin.PULL_UP)
        
        # Communication interfaces
        self.i2c = I2C(0, sda=Pin(I2C_SDA), scl=Pin(I2C_SCL))
        
        # Analog inputs (if available)
        if 'TEMP_SENSOR' in globals():
            self.temp_adc = ADC(Pin(TEMP_SENSOR))
            
    def set_status_brightness(self, brightness):
        """Set LED brightness (0-100%)"""
        duty = int(brightness * 655.35)  # Convert to 16-bit PWM
        self.status_led.duty_u16(duty)
        
    def indicate_error(self, error_code):
        """Flash error LED with specific pattern"""
        for _ in range(error_code):
            self.error_led.duty_u16(32767)  # Half brightness
            time.sleep(0.2)
            self.error_led.duty_u16(0)
            time.sleep(0.2)
```

---

## Arduino Format  

**File:** `firmware/include/pinmap_arduino.h`

### Structure

```c
/**
 * Pin mapping constants for Arduino/C++
 * Generated from: hardware/exports/sample_netlist.csv
 * MCU: RP2040 (Reference: U1)
 * Generated: 2024-01-15T10:30:00Z
 * 
 * ⚠️  AUTOMATICALLY GENERATED - DO NOT EDIT MANUALLY
 *     Regenerate using: python -m tools.pinmapgen.cli
 */

#ifndef PINMAP_ARDUINO_H
#define PINMAP_ARDUINO_H

// GPIO Pin Assignments
#define LED_STATUS     15    // GP15 - Physical pin 20
#define LED_ERROR      16    // GP16 - Physical pin 21
#define BUTTON_INPUT   17    // GP17 - Physical pin 22

// Communication Interfaces
#define I2C_SDA        4     // GP4 - Physical pin 6  
#define I2C_SCL        5     // GP5 - Physical pin 7
#define UART_TX        0     // GP0 - Physical pin 1
#define UART_RX        1     // GP1 - Physical pin 2

// USB Interface (Hardware-managed)
#define USB_DP         24    // GP24 - Physical pin 35
#define USB_DM         25    // GP25 - Physical pin 34

/* Pin validation warnings:
 * - LED_STATUS (GP15): Consider PWM for brightness control
 * - I2C pins (GP4/GP5): Verify pull-up resistors on schematic
 */

/* Usage examples:
 * #include "pinmap_arduino.h"
 * 
 * void setup() {
 *   pinMode(LED_STATUS, OUTPUT);
 *   pinMode(BUTTON_INPUT, INPUT_PULLUP);
 *   Wire.begin(I2C_SDA, I2C_SCL);
 * }
 */

#endif // PINMAP_ARDUINO_H
```

### Usage Patterns

**Basic Arduino sketch:**
```cpp
// main.ino
#include "pinmap_arduino.h"
#include <Wire.h>

void setup() {
  Serial.begin(115200);
  
  // Initialize GPIO using generated constants
  pinMode(LED_STATUS, OUTPUT);
  pinMode(LED_ERROR, OUTPUT);
  pinMode(BUTTON_INPUT, INPUT_PULLUP);
  
  // Initialize I2C with correct pins
  Wire.begin(I2C_SDA, I2C_SCL);
  
  Serial.println("Hardware initialized with PinmapGen constants");
}

void loop() {
  // Read button state
  if (digitalRead(BUTTON_INPUT) == LOW) {
    digitalWrite(LED_STATUS, HIGH);
    delay(100);
    digitalWrite(LED_STATUS, LOW);
    delay(100);
  }
  
  // Blink error LED every 2 seconds
  static unsigned long lastBlink = 0;
  if (millis() - lastBlink > 2000) {
    digitalWrite(LED_ERROR, !digitalRead(LED_ERROR));
    lastBlink = millis();
  }
}
```

**PlatformIO integration:**
```cpp
// src/hardware_abstraction.cpp
#include "pinmap_arduino.h"
#include <Arduino.h>

class HardwareManager {
private:
  bool status_led_state = false;
  unsigned long last_button_time = 0;
  
public:
  void init() {
    // Configure pins using generated constants
    pinMode(LED_STATUS, OUTPUT);
    pinMode(LED_ERROR, OUTPUT); 
    pinMode(BUTTON_INPUT, INPUT_PULLUP);
    
    // Initialize communication
    Wire.begin(I2C_SDA, I2C_SCL);
    Serial1.begin(115200, SERIAL_8N1, UART_RX, UART_TX);
    
    // Initial state
    digitalWrite(LED_STATUS, LOW);
    digitalWrite(LED_ERROR, LOW);
  }
  
  bool readButton() {
    bool current_state = digitalRead(BUTTON_INPUT) == LOW;
    unsigned long now = millis();
    
    // Simple debouncing
    if (current_state && (now - last_button_time > 50)) {
      last_button_time = now;
      return true;
    }
    return false;
  }
  
  void setStatusLED(bool state) {
    digitalWrite(LED_STATUS, state ? HIGH : LOW);
    status_led_state = state;
  }
  
  void toggleStatusLED() {
    setStatusLED(!status_led_state);
  }
  
  void flashError(uint8_t count) {
    for (uint8_t i = 0; i < count; i++) {
      digitalWrite(LED_ERROR, HIGH);
      delay(200);
      digitalWrite(LED_ERROR, LOW);
      delay(200);
    }
  }
};

// Global hardware manager
HardwareManager hardware;

void setup() {
  hardware.init();
}

void loop() {
  if (hardware.readButton()) {
    hardware.toggleStatusLED();
  }
  
  // Handle other tasks...
}
```

**Multi-file project structure:**
```cpp
// include/config.h
#ifndef CONFIG_H
#define CONFIG_H

#include "pinmap_arduino.h"

// Application configuration using pin constants
#define BUTTON_DEBOUNCE_MS    50
#define LED_BLINK_PERIOD_MS   1000  
#define I2C_FREQUENCY         100000
#define UART_BAUDRATE        115200

// Validate pin assignments at compile time
#if !defined(LED_STATUS) || !defined(BUTTON_INPUT)
#error "Required pins not defined in pinmap_arduino.h"
#endif

#endif // CONFIG_H
```

```cpp
// src/peripherals.cpp
#include "config.h"
#include <Wire.h>

namespace Peripherals {
  void initI2C() {
    Wire.begin(I2C_SDA, I2C_SCL);
    Wire.setClock(I2C_FREQUENCY);
  }
  
  bool scanI2CDevice(uint8_t address) {
    Wire.beginTransmission(address);
    return (Wire.endTransmission() == 0);
  }
  
  void initSerial() {
    Serial1.begin(UART_BAUDRATE, SERIAL_8N1, UART_RX, UART_TX);
    while (!Serial1) { delay(10); } // Wait for serial ready
  }
}
```

---

## Markdown Format

**File:** `firmware/docs/PINOUT.md`

### Structure

```markdown
# Pinout Documentation

**Generated from:** hardware/exports/sample_netlist.csv  
**MCU:** RP2040 (Reference: U1)  
**Generated:** 2024-01-15 10:30:00  

⚠️ **AUTOMATICALLY GENERATED** - Do not edit manually  
Regenerate using: `python -m tools.pinmapgen.cli`

---

## Pin Summary

| Net Name | Physical Pin | Logical Pin | Role | Capabilities | Notes |
|----------|-------------|-------------|------|--------------|-------|
| LED_STATUS | 20 | GP15 | output | gpio, pwm | Consider PWM for brightness |
| LED_ERROR | 21 | GP16 | output | gpio, pwm | |  
| BUTTON_INPUT | 22 | GP17 | input | gpio | Built-in pull-up available |
| I2C_SDA | 6 | GP4 | bidirectional | gpio, i2c | Requires external pull-up |
| I2C_SCL | 7 | GP5 | bidirectional | gpio, i2c | Requires external pull-up |
| UART_TX | 1 | GP0 | output | gpio, uart | |
| UART_RX | 2 | GP1 | input | gpio, uart | |
| USB_DP | 35 | GP24 | usb | usb | Hardware-managed USB data+ |
| USB_DM | 34 | GP25 | usb | usb | Hardware-managed USB data- |

---

## Pin Details

### LED_STATUS (GP15)
- **Physical Pin:** 20
- **Role:** Output  
- **Capabilities:** GPIO, PWM
- **Usage:** Status indicator LED
- **Notes:** Consider PWM for brightness control

### BUTTON_INPUT (GP17)  
- **Physical Pin:** 22
- **Role:** Input
- **Capabilities:** GPIO
- **Usage:** User input button
- **Notes:** Built-in pull-up resistor available

### I2C Interface (GP4/GP5)
- **SDA Pin:** GP4 (Physical 6)
- **SCL Pin:** GP5 (Physical 7)  
- **Usage:** I2C communication bus
- **Requirements:** External 4.7kΩ pull-up resistors to 3.3V
- **Max Frequency:** 1MHz (Fast Mode+)

### USB Interface (GP24/GP25)
- **Data+ Pin:** GP24 (Physical 35)
- **Data- Pin:** GP25 (Physical 34)
- **Usage:** USB communication (hardware-managed)
- **Notes:** Do not use for GPIO when USB is active

---

## Validation Results

✅ **No errors detected**  
⚠️ **2 warnings:**
- LED_STATUS (GP15): Consider PWM for brightness control
- I2C pins (GP4/GP5): Verify pull-up resistors on schematic

---

## MCU Information

**Type:** RP2040  
**Package:** QFN-56  
**Total Pins:** 56  
**GPIO Pins:** 30  
**Used GPIO:** 7 of 30 (23% utilization)

### Capabilities Summary
- **ADC Channels:** 3 available (GP26, GP27, GP28)
- **PWM Channels:** 16 available  
- **UART Interfaces:** 2 available
- **I2C Interfaces:** 2 available  
- **SPI Interfaces:** 2 available

---

## Code Examples

### MicroPython
```python
from machine import Pin, I2C
from pinmap_micropython import *

# Initialize hardware
led = Pin(LED_STATUS, Pin.OUT)
button = Pin(BUTTON_INPUT, Pin.IN, Pin.PULL_UP)
i2c = I2C(0, sda=Pin(I2C_SDA), scl=Pin(I2C_SCL))

# Blink LED when button pressed
while True:
    if not button.value():
        led.toggle()
        time.sleep(0.1)
```

### Arduino
```cpp
#include "pinmap_arduino.h"

void setup() {
  pinMode(LED_STATUS, OUTPUT);
  pinMode(BUTTON_INPUT, INPUT_PULLUP);
  Wire.begin(I2C_SDA, I2C_SCL);
}

void loop() {
  if (digitalRead(BUTTON_INPUT) == LOW) {
    digitalWrite(LED_STATUS, HIGH);
    delay(100);
    digitalWrite(LED_STATUS, LOW);
  }
}
```

---

## Design Notes

This pinout configuration provides:
- **Status indication** via two independent LEDs  
- **User input** through debounced button
- **I2C communication** for sensor interfacing
- **Serial communication** for debugging/logging
- **USB connectivity** for programming and data transfer

**Recommended schematic additions:**
- 4.7kΩ pull-up resistors on I2C_SDA and I2C_SCL
- 100nF decoupling capacitors near power pins  
- ESD protection on USB lines
- Current limiting resistors for LEDs (330Ω typical)

**Future expansion possibilities:**
- ADC inputs available on GP26, GP27, GP28
- Additional I2C interface available (GP2/GP3 or GP6/GP7)
- SPI interface available for high-speed peripherals  
- PWM outputs available on all GPIO pins
```

### Usage Patterns

**Documentation website generation:**
```python
# docs/generate_site.py
import markdown
from pathlib import Path

def build_hardware_docs():
    """Convert PinmapGen markdown to website format"""
    
    # Read generated pinout documentation
    pinout_md = Path('firmware/docs/PINOUT.md').read_text()
    
    # Convert to HTML with extensions
    md = markdown.Markdown(extensions=['tables', 'codehilite', 'toc'])
    html_content = md.convert(pinout_md)
    
    # Wrap in site template
    site_template = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Hardware Pinout Reference</title>
        <link rel="stylesheet" href="styles.css">
    </head>
    <body>
        <nav>
            <a href="#pin-summary">Pin Summary</a>
            <a href="#pin-details">Details</a>
            <a href="#code-examples">Examples</a>
        </nav>
        <main>
            {content}
        </main>
    </body>
    </html>
    """
    
    final_html = site_template.format(content=html_content)
    Path('docs/site/hardware.html').write_text(final_html)

if __name__ == "__main__":
    build_hardware_docs()
```

**Technical review checklist generation:**
```python
# Generate hardware review checklist from pinout docs
def generate_review_checklist():
    """Extract validation items for hardware review"""
    
    with open('firmware/docs/PINOUT.md', 'r') as f:
        content = f.read()
    
    checklist = """
    # Hardware Review Checklist
    
    **Generated from pinout validation results**
    
    ## Pin Assignment Review
    """
    
    # Extract validation warnings
    if "⚠️" in content:
        checklist += "\n### Validation Warnings\n"
        # Parse warnings from markdown and create checklist items
        lines = content.split('\n')
        for line in lines:
            if 'Consider PWM' in line:
                checklist += "- [ ] Verify PWM capability needed for LED brightness control\n"
            if 'pull-up resistors' in line:
                checklist += "- [ ] Confirm I2C pull-up resistors present on schematic\n"
    
    # Add standard review items
    checklist += """
    ## Standard Checks
    - [ ] All required nets connected to MCU
    - [ ] No GPIO pins assigned to power/ground nets  
    - [ ] Differential pairs routed with matched impedance
    - [ ] Sensitive analog pins isolated from digital switching
    - [ ] Current limiting resistors sized appropriately
    """
    
    return checklist
```

---

## Mermaid Format

**File:** `firmware/docs/pinout.mmd`

### Structure

```mermaid
graph TB
    subgraph "RP2040 Package (QFN-56)"
        MCU[RP2040<br/>U1]
        
        MCU --> |Pin 20<br/>GP15| LED_STATUS[LED_STATUS<br/>Output]
        MCU --> |Pin 21<br/>GP16| LED_ERROR[LED_ERROR<br/>Output]
        MCU --> |Pin 22<br/>GP17| BUTTON_INPUT[BUTTON_INPUT<br/>Input]
        
        MCU --> |Pin 6<br/>GP4| I2C_SDA[I2C_SDA<br/>Bidirectional]  
        MCU --> |Pin 7<br/>GP5| I2C_SCL[I2C_SCL<br/>Bidirectional]
        
        MCU --> |Pin 1<br/>GP0| UART_TX[UART_TX<br/>Output]
        MCU --> |Pin 2<br/>GP1| UART_RX[UART_RX<br/>Input]
        
        MCU --> |Pin 35<br/>GP24| USB_DP[USB_DP<br/>USB Data+]
        MCU --> |Pin 34<br/>GP25| USB_DM[USB_DM<br/>USB Data-]
    end
    
    subgraph "External Components"
        LED1[Status LED<br/>D1]
        LED2[Error LED<br/>D2] 
        BTN[Push Button<br/>SW1]
        I2C_DEV[I2C Devices<br/>Sensors, etc.]
        UART_DEV[UART Device<br/>GPS, Debug, etc.]
        USB_CONN[USB Connector<br/>J1]
    end
    
    LED_STATUS --> LED1
    LED_ERROR --> LED2
    BUTTON_INPUT --> BTN
    I2C_SDA --> I2C_DEV
    I2C_SCL --> I2C_DEV
    UART_TX --> UART_DEV
    UART_RX --> UART_DEV
    USB_DP --> USB_CONN
    USB_DM --> USB_CONN
    
    classDef output fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
    classDef input fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    classDef bidir fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef usb fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    
    class LED_STATUS,LED_ERROR,UART_TX output
    class BUTTON_INPUT,UART_RX input  
    class I2C_SDA,I2C_SCL bidir
    class USB_DP,USB_DM usb
```

### Usage Patterns

**Presentation integration:**
```markdown
<!-- slides.md - Reveal.js presentation -->
# Hardware Architecture Overview

## System Connectivity

<div class="mermaid">
graph TB
    <!-- Include generated Mermaid diagram -->
</div>

- **30 GPIO pins** available on RP2040
- **8 pins assigned** for this design
- **23% utilization** allows for future expansion
```

**Documentation embedding:**
```html
<!-- README.html -->
<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
</head>
<body>
    <h1>System Architecture</h1>
    
    <!-- Embed generated Mermaid diagram -->
    <div class="mermaid">
        <!-- Copy content from firmware/docs/pinout.mmd -->
    </div>
    
    <p>This diagram shows all pin connections automatically generated from the hardware netlist.</p>
</body>
</html>
```

**Confluence/Notion integration:**
```javascript
// confluence_updater.js
const fs = require('fs');
const axios = require('axios');

async function updateConfluencePage() {
    // Read generated Mermaid diagram
    const mermaidContent = fs.readFileSync('firmware/docs/pinout.mmd', 'utf8');
    
    // Confluence API call to update hardware documentation page
    const pageContent = `
    <h1>Hardware Pinout</h1>
    <ac:structured-macro ac:name="mermaid">
        <ac:parameter ac:name="graphDefinition">
            ${mermaidContent}
        </ac:parameter>
    </ac:structured-macro>
    <p><em>Automatically updated from PinmapGen on ${new Date().toISOString()}</em></p>
    `;
    
    await axios.put(`${CONFLUENCE_BASE_URL}/rest/api/content/${PAGE_ID}`, {
        version: { number: versionNumber + 1 },
        title: 'Hardware Pinout Reference',
        type: 'page',
        body: { storage: { value: pageContent, representation: 'storage' } }
    });
}
```

---

## Format Comparison

| Aspect | JSON | MicroPython | Arduino | Markdown | Mermaid |
|--------|------|-------------|---------|----------|---------|
| **Machine Readable** | ✅ Full | ✅ Partial | ✅ Partial | ❌ No | ❌ No |
| **Human Readable** | ❌ No | ✅ Good | ✅ Good | ✅ Excellent | ✅ Visual |
| **Code Integration** | ⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ | ⭐ | ⭐ |
| **Documentation** | ⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐ |
| **Automation** | ⭐⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ | ⭐⭐ |
| **Version Control** | ✅ Diffs well | ✅ Diffs well | ✅ Diffs well | ✅ Diffs well | ❌ Complex diffs |

**Recommendation:** Use all formats together - each serves a specific purpose in the development workflow.

---

## Customization and Extension

### Adding Custom Metadata

**Extend JSON output:**
```python
# In emit_json.py
def add_custom_metadata(pinmap_data, custom_info):
    """Add project-specific metadata to JSON output"""
    pinmap_data['custom'] = {
        'project_name': custom_info.get('project', 'Unknown'),
        'board_revision': custom_info.get('revision', 'A'),
        'design_rules': custom_info.get('rules', {}),
        'component_suppliers': custom_info.get('suppliers', {})
    }
    return pinmap_data
```

**Custom Mermaid styling:**
```javascript
// Custom CSS for Mermaid diagrams
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#ffffff',
    'primaryTextColor': '#333333',
    'primaryBorderColor': '#0078d4',
    'lineColor': '#666666'
  }
}}%%
```

### Format-Specific Optimizations

**MicroPython performance:**
```python
# Generate lookup tables for fast pin access
PIN_LOOKUP = {
    'led_status': LED_STATUS,
    'led_error': LED_ERROR,
    'button': BUTTON_INPUT,
    # ... other pins
}

def get_pin(name):
    """Fast pin lookup by semantic name"""
    return PIN_LOOKUP.get(name.lower())
```

**Arduino compile-time validation:**
```cpp
// Add compile-time checks to Arduino header
#if LED_STATUS >= 30
#error "LED_STATUS pin number exceeds RP2040 GPIO range"
#endif

#if I2C_SDA == I2C_SCL  
#error "I2C SDA and SCL cannot be the same pin"
#endif
```

All output formats work together to provide a complete toolchain from hardware design to firmware deployment, with each format optimized for its specific use case and target audience.
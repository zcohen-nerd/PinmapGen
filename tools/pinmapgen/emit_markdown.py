"""
Markdown Documentation Emitter for PinmapGen.

Generates PINOUT.md documentation files.
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Union


def emit_markdown_docs(canonical_dict: Dict[str, Any], output_path: Union[Path, str]) -> None:
    """
    Generate Markdown pinout documentation from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary with pins and differential pairs
        output_path: Path to output Markdown file
    """
    # Ensure we have a Path object
    if isinstance(output_path, str):
        output_path = Path(output_path)
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate Markdown content
    content = generate_pinout_documentation(canonical_dict)
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)


def generate_pinout_documentation(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate complete Markdown pinout documentation from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Markdown documentation string
    """
    lines = []
    
    mcu = canonical_dict.get('mcu', 'unknown').upper()
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    metadata = canonical_dict.get('metadata', {})
    
    # Document header
    lines.extend([
        f'# {mcu} Pinout Documentation',
        '',
        f'**Generated by PinmapGen on {timestamp}**',
        '',
        '## Overview',
        '',
        f'This document describes the pin assignments for the {mcu} microcontroller.',
        f'- **Total nets:** {metadata.get("total_nets", 0)}',
        f'- **Total pins:** {metadata.get("total_pins", 0)}',
        f'- **Differential pairs:** {metadata.get("differential_pairs_count", 0)}',
        '',
    ])
    
    # Special pins section
    special_pins = metadata.get('special_pins_used', [])
    if special_pins:
        lines.extend([
            '## Special Function Pins',
            '',
            'The following pins have special functions on the ' + mcu + ':',
            '',
        ])
        
        for pin in special_pins:
            function = _get_special_function(pin)
            lines.append(f'- **{pin}**: {function}')
        
        lines.extend(['', '---', ''])
    
    # Single-ended pins table
    lines.extend([
        '## Single-Ended Pin Assignments',
        '',
        generate_single_ended_table(canonical_dict),
        '',
    ])
    
    # Differential pairs table (if any exist)
    diff_pairs = canonical_dict.get('differential_pairs', [])
    if diff_pairs:
        lines.extend([
            '## Differential Pair Assignments',
            '',
            generate_differential_pairs_table(canonical_dict),
            '',
        ])
    
    # Differential pairs section
    diff_pairs = canonical_dict.get('differential_pairs', [])
    if diff_pairs:
        lines.extend([
            '## Differential Pairs',
            '',
            'The following signals are routed as differential pairs:',
            '',
        ])
        
        for pair in diff_pairs:
            pos_net = pair.get('positive', '')
            neg_net = pair.get('negative', '')
            lines.extend([
                f'### {pos_net} / {neg_net}',
                '',
                f'- **Positive:** {pos_net}',
                f'- **Negative:** {neg_net}',
                '',
                '> **Note:** These signals should be routed with matched lengths and controlled impedance.',
                '',
            ])
    
    # Usage examples
    lines.extend([
        '## Usage Examples',
        '',
        '### MicroPython',
        '',
        '```python',
        'from machine import Pin',
        'from pinmap_micropython import *',
        '',
        '# Configure pins',
    ])
    
    # Add a few example pin configurations
    pins = canonical_dict.get('pins', {})
    examples_added = 0
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1 and examples_added < 3:
            sanitized_name = _sanitize_identifier(net_name)
            if 'LED' in net_name.upper():
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.OUT)')
            elif 'BUTTON' in net_name.upper():
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.IN, Pin.PULL_UP)')
            else:
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.OUT)')
            examples_added += 1
    
    lines.extend([
        '```',
        '',
        '### Arduino/PlatformIO',
        '',
        '```cpp',
        '#include "pinmap_arduino.h"',
        '',
        'void setup() {',
    ])
    
    # Add Arduino examples
    examples_added = 0
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1 and examples_added < 3:
            sanitized_name = _sanitize_c_identifier(net_name)
            if 'LED' in net_name.upper():
                lines.append(f'  pinMode({sanitized_name}, OUTPUT);')
            elif 'BUTTON' in net_name.upper():
                lines.append(f'  pinMode({sanitized_name}, INPUT_PULLUP);')
            else:
                lines.append(f'  pinMode({sanitized_name}, OUTPUT);')
            examples_added += 1
    
    lines.extend([
        '}',
        '```',
        '',
        '---',
        '',
        f'*This document was automatically generated by PinmapGen v0.1.0*',
        ''
    ])
    
    return '\n'.join(lines)


def generate_single_ended_table(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate Markdown table of single-ended pin mappings.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Markdown table string for single-ended pins
    """
    lines = []
    pins = canonical_dict.get('pins', {})
    
    # Get differential pair net names to exclude them
    diff_pair_nets = set()
    diff_pairs = canonical_dict.get('differential_pairs', [])
    for pair in diff_pairs:
        diff_pair_nets.add(pair.get('positive', ''))
        diff_pair_nets.add(pair.get('negative', ''))
    
    # Collect single-ended pins only
    pin_data = []
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1 and net_name not in diff_pair_nets:
            pin = pin_list[0]
            match = re.match(r'GP(\d+)', pin)
            if match:
                pin_num = int(match.group(1))
                function = _get_special_function(pin)
                notes = _get_pin_notes(net_name, pin, canonical_dict)
                pin_data.append((pin_num, net_name, pin, function, notes))
    
    if not pin_data:
        return '*No single-ended pin assignments found.*'
    
    # Table header
    lines.extend([
        '| Net Name | Pin | Function | Notes |',
        '|----------|-----|----------|-------|',
    ])
    
    # Sort by pin number
    pin_data.sort(key=lambda x: x[0])
    
    # Generate table rows
    for _, net_name, pin, function, notes in pin_data:
        # Escape pipe characters in content
        net_name = net_name.replace('|', '\\|')
        function = function.replace('|', '\\|')
        notes = notes.replace('|', '\\|')
        
        lines.append(f'| `{net_name}` | `{pin}` | {function} | {notes} |')
    
    return '\n'.join(lines)


def generate_differential_pairs_table(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate Markdown table of differential pair assignments.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Markdown table string for differential pairs
    """
    lines = []
    pins = canonical_dict.get('pins', {})
    diff_pairs = canonical_dict.get('differential_pairs', [])
    
    if not diff_pairs:
        return '*No differential pairs found.*'
    
    # Table header
    lines.extend([
        '| Signal | Positive Pin | Negative Pin | Function | Notes |',
        '|--------|--------------|--------------|----------|-------|',
    ])
    
    # Generate table rows for each differential pair
    for pair in diff_pairs:
        pos_net = pair.get('positive', '')
        neg_net = pair.get('negative', '')
        
        # Get pin assignments
        pos_pin = pins.get(pos_net, [''])[0] if pos_net in pins else ''
        neg_pin = pins.get(neg_net, [''])[0] if neg_net in pins else ''
        
        # Determine signal type and function
        signal_name = _get_differential_signal_name(pos_net, neg_net)
        function = _get_differential_function(pos_net, neg_net)
        notes = _get_differential_notes(pos_net, neg_net)
        
        # Escape pipe characters
        signal_name = signal_name.replace('|', '\\|')
        function = function.replace('|', '\\|')
        notes = notes.replace('|', '\\|')
        
        lines.append(
            f'| `{signal_name}` | `{pos_pin}` | `{neg_pin}` | '
            f'{function} | {notes} |'
        )
    
    return '\n'.join(lines)


def _sanitize_identifier(name: str) -> str:
    """Convert net name to valid identifier."""
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    if not sanitized or sanitized == '_':
        sanitized = 'UNNAMED_PIN'
    return sanitized.upper()


def _sanitize_c_identifier(name: str) -> str:
    """Convert net name to valid C identifier."""
    return _sanitize_identifier(name)


def _get_special_function(pin: str) -> str:
    """Get special function description for a pin."""
    special_functions = {
        'GP24': 'USB D- (Data Minus)',
        'GP25': 'USB D+ (Data Plus)',
        'GP26': 'ADC Channel 0',
        'GP27': 'ADC Channel 1',
        'GP28': 'ADC Channel 2',
        'GP29': 'ADC Channel 3',
        'GP23': 'SMPS Power Mode',
    }
    
    return special_functions.get(pin, 'General Purpose I/O')


def _get_pin_notes(net_name: str, pin: str, canonical_dict: Dict[str, Any]) -> str:
    """Get additional notes for a pin (excluding differential pair info)."""
    notes = []
    
    # Add function-specific notes
    if 'USB' in net_name.upper():
        notes.append('USB data line')
    elif 'ADC' in net_name.upper() or 'ANALOG' in net_name.upper():
        notes.append('Analog input capable')
    elif 'PWM' in net_name.upper():
        notes.append('PWM output capable')
    elif 'I2C' in net_name.upper():
        notes.append('I2C bus')
    elif 'SPI' in net_name.upper():
        notes.append('SPI bus')
    elif 'CAN' in net_name.upper():
        notes.append('CAN bus')
    
    return ' • '.join(notes) if notes else '-'


def _get_differential_signal_name(pos_net: str, neg_net: str) -> str:
    """Extract signal name from differential pair net names."""
    # Common patterns for differential signals
    if 'USB' in pos_net.upper() or 'USB' in neg_net.upper():
        return 'USB'
    elif 'CAN' in pos_net.upper() or 'CAN' in neg_net.upper():
        return 'CAN'
    elif 'UART' in pos_net.upper() or 'UART' in neg_net.upper():
        return 'UART'
    elif 'ETH' in pos_net.upper() or 'ETH' in neg_net.upper():
        return 'Ethernet'
    else:
        # Try to extract common prefix
        common_prefix = ''
        for i, (c1, c2) in enumerate(zip(pos_net, neg_net)):
            if c1 == c2:
                common_prefix += c1
            else:
                break
        
        # Clean up common prefix
        common_prefix = common_prefix.rstrip('_-+')
        return common_prefix if common_prefix else f'{pos_net}/{neg_net}'


def _get_differential_function(pos_net: str, neg_net: str) -> str:
    """Get function description for differential pair."""
    signal_name = _get_differential_signal_name(pos_net, neg_net).upper()
    
    if 'USB' in signal_name:
        return 'USB 2.0 Data'
    elif 'CAN' in signal_name:
        return 'CAN Bus'
    elif 'UART' in signal_name:
        return 'UART Differential'
    elif 'ETH' in signal_name:
        return 'Ethernet Pair'
    else:
        return 'Differential Signal'


def _get_differential_notes(pos_net: str, neg_net: str) -> str:
    """Get notes for differential pair."""
    signal_name = _get_differential_signal_name(pos_net, neg_net).upper()
    
    if 'USB' in signal_name:
        return 'Route with 90Ω differential impedance'
    elif 'CAN' in signal_name:
        return 'Route with 120Ω differential impedance'
    elif 'ETH' in signal_name:
        return 'Route with 100Ω differential impedance'
    else:
        return 'Match trace lengths and controlled impedance'
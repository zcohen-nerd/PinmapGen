"""
Markdown Documentation Emitter for PinmapGen.

Generates PINOUT.md documentation files.
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Union


def emit_markdown_docs(canonical_dict: Dict[str, Any], output_path: Union[Path, str]) -> None:
    """
    Generate Markdown pinout documentation from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary with pins and differential pairs
        output_path: Path to output Markdown file
    """
    # Ensure we have a Path object
    if isinstance(output_path, str):
        output_path = Path(output_path)
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate Markdown content
    content = generate_pinout_documentation(canonical_dict)
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)


def generate_pinout_documentation(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate complete Markdown pinout documentation from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Markdown documentation string
    """
    lines = []
    
    mcu = canonical_dict.get('mcu', 'unknown').upper()
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    metadata = canonical_dict.get('metadata', {})
    
    # Document header
    lines.extend([
        f'# {mcu} Pinout Documentation',
        '',
        f'**Generated by PinmapGen on {timestamp}**',
        '',
        '## Overview',
        '',
        f'This document describes the pin assignments for the {mcu} microcontroller.',
        f'- **Total nets:** {metadata.get("total_nets", 0)}',
        f'- **Total pins:** {metadata.get("total_pins", 0)}',
        f'- **Differential pairs:** {metadata.get("differential_pairs_count", 0)}',
        '',
    ])
    
    # Special pins section
    special_pins = metadata.get('special_pins_used', [])
    if special_pins:
        lines.extend([
            '## Special Function Pins',
            '',
            'The following pins have special functions on the ' + mcu + ':',
            '',
        ])
        
        for pin in special_pins:
            function = _get_special_function(pin)
            lines.append(f'- **{pin}**: {function}')
        
        lines.extend(['', '---', ''])
    
    # Main pinout table
    lines.extend([
        '## Pin Assignments',
        '',
        generate_pinout_table(canonical_dict),
        '',
    ])
    
    # Differential pairs section
    diff_pairs = canonical_dict.get('differential_pairs', [])
    if diff_pairs:
        lines.extend([
            '## Differential Pairs',
            '',
            'The following signals are routed as differential pairs:',
            '',
        ])
        
        for pair in diff_pairs:
            pos_net = pair.get('positive', '')
            neg_net = pair.get('negative', '')
            lines.extend([
                f'### {pos_net} / {neg_net}',
                '',
                f'- **Positive:** {pos_net}',
                f'- **Negative:** {neg_net}',
                '',
                '> **Note:** These signals should be routed with matched lengths and controlled impedance.',
                '',
            ])
    
    # Usage examples
    lines.extend([
        '## Usage Examples',
        '',
        '### MicroPython',
        '',
        '```python',
        'from machine import Pin',
        'from pinmap_micropython import *',
        '',
        '# Configure pins',
    ])
    
    # Add a few example pin configurations
    pins = canonical_dict.get('pins', {})
    examples_added = 0
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1 and examples_added < 3:
            sanitized_name = _sanitize_identifier(net_name)
            if 'LED' in net_name.upper():
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.OUT)')
            elif 'BUTTON' in net_name.upper():
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.IN, Pin.PULL_UP)')
            else:
                lines.append(f'{sanitized_name.lower()} = Pin({sanitized_name}, Pin.OUT)')
            examples_added += 1
    
    lines.extend([
        '```',
        '',
        '### Arduino/PlatformIO',
        '',
        '```cpp',
        '#include "pinmap_arduino.h"',
        '',
        'void setup() {',
    ])
    
    # Add Arduino examples
    examples_added = 0
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1 and examples_added < 3:
            sanitized_name = _sanitize_c_identifier(net_name)
            if 'LED' in net_name.upper():
                lines.append(f'  pinMode({sanitized_name}, OUTPUT);')
            elif 'BUTTON' in net_name.upper():
                lines.append(f'  pinMode({sanitized_name}, INPUT_PULLUP);')
            else:
                lines.append(f'  pinMode({sanitized_name}, OUTPUT);')
            examples_added += 1
    
    lines.extend([
        '}',
        '```',
        '',
        '---',
        '',
        f'*This document was automatically generated by PinmapGen v0.1.0*',
        ''
    ])
    
    return '\n'.join(lines)


def generate_pinout_table(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate Markdown table of pinout mappings from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Markdown table string
    """
    lines = []
    pins = canonical_dict.get('pins', {})
    
    if not pins:
        return '*No pin assignments found.*'
    
    # Table header
    lines.extend([
        '| Net Name | Pin | Function | Notes |',
        '|----------|-----|----------|-------|',
    ])
    
    # Collect and sort pin data
    pin_data = []
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1:  # Single pin nets only
            pin = pin_list[0]
            match = re.match(r'GP(\d+)', pin)
            if match:
                pin_num = int(match.group(1))
                function = _get_special_function(pin)
                notes = _get_pin_notes(net_name, pin, canonical_dict)
                pin_data.append((pin_num, net_name, pin, function, notes))
    
    # Sort by pin number
    pin_data.sort(key=lambda x: x[0])
    
    # Generate table rows
    for _, net_name, pin, function, notes in pin_data:
        # Escape pipe characters in content
        net_name = net_name.replace('|', '\\|')
        function = function.replace('|', '\\|')
        notes = notes.replace('|', '\\|')
        
        lines.append(f'| `{net_name}` | `{pin}` | {function} | {notes} |')
    
    return '\n'.join(lines)


def _sanitize_identifier(name: str) -> str:
    """Convert net name to valid identifier."""
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    if not sanitized or sanitized == '_':
        sanitized = 'UNNAMED_PIN'
    return sanitized.upper()


def _sanitize_c_identifier(name: str) -> str:
    """Convert net name to valid C identifier."""
    return _sanitize_identifier(name)


def _get_special_function(pin: str) -> str:
    """Get special function description for a pin."""
    special_functions = {
        'GP24': 'USB D- (Data Minus)',
        'GP25': 'USB D+ (Data Plus)',
        'GP26': 'ADC Channel 0',
        'GP27': 'ADC Channel 1',
        'GP28': 'ADC Channel 2',
        'GP29': 'ADC Channel 3',
        'GP23': 'SMPS Power Mode',
    }
    
    return special_functions.get(pin, 'General Purpose I/O')


def _get_pin_notes(net_name: str, pin: str, canonical_dict: Dict[str, Any]) -> str:
    """Get additional notes for a pin."""
    notes = []
    
    # Check if part of differential pair
    diff_pairs = canonical_dict.get('differential_pairs', [])
    for pair in diff_pairs:
        if net_name in [pair.get('positive'), pair.get('negative')]:
            partner = pair.get('negative') if net_name == pair.get('positive') else pair.get('positive')
            notes.append(f'Differential pair with `{partner}`')
            break
    
    # Add function-specific notes
    if 'USB' in net_name.upper():
        notes.append('USB data line')
    elif 'ADC' in net_name.upper() or 'ANALOG' in net_name.upper():
        notes.append('Analog input capable')
    elif 'PWM' in net_name.upper():
        notes.append('PWM output capable')
    elif 'I2C' in net_name.upper():
        notes.append('I2C bus')
    elif 'SPI' in net_name.upper():
        notes.append('SPI bus')
    elif 'CAN' in net_name.upper():
        notes.append('CAN bus')
    
    return ' â€¢ '.join(notes) if notes else '-'
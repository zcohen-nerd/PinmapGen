"""
MicroPython Emitter for PinmapGen.

Generates pinmap_micropython.py files for MicroPython projects.
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Union


def emit_micropython(canonical_dict: Dict[str, Any], output_path: Union[Path, str]) -> None:
    """
    Generate MicroPython pinmap file from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary with pins and differential pairs
        output_path: Path to output Python file
    """
    # Ensure we have a Path object
    if isinstance(output_path, str):
        output_path = Path(output_path)
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate MicroPython code
    code = generate_micropython_constants(canonical_dict)
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(code)


def generate_micropython_constants(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate MicroPython pin constant definitions from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        MicroPython code string
    """
    lines = []
    
    # File header
    mcu = canonical_dict.get('mcu', 'unknown').upper()
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    lines.extend([
        '"""',
        f'Auto-generated pinmap for {mcu}',
        'Generated by PinmapGen',
        f'Timestamp: {timestamp}',
        '',
        'Usage:',
        '    from machine import Pin',
        '    from pinmap_micropython import LED_DATA, BUTTON',
        '    ',
        '    led = Pin(LED_DATA, Pin.OUT)',
        '    button = Pin(BUTTON, Pin.IN, Pin.PULL_UP)',
        '"""',
        '',
        '# Pin constant definitions',
    ])
    
    # Extract pins and sort by pin number for consistent output
    pins = canonical_dict.get('pins', {})
    pin_definitions = []
    
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1:  # Single pin nets only
            pin = pin_list[0]
            # Extract pin number (GP0 -> 0)
            match = re.match(r'GP(\d+)', pin)
            if match:
                pin_num = int(match.group(1))
                # Create valid Python identifier from net name
                const_name = _sanitize_identifier(net_name)
                
                # Add special pin comments
                comment = _get_pin_comment(pin, canonical_dict)
                
                pin_definitions.append((pin_num, const_name, pin_num, comment))
    
    # Sort by pin number
    pin_definitions.sort(key=lambda x: x[0])
    
    # Generate constant definitions
    max_name_len = max(len(name) for _, name, _, _ in pin_definitions) if pin_definitions else 0
    
    for _, const_name, pin_num, comment in pin_definitions:
        line = f"{const_name.ljust(max_name_len)} = {pin_num}"
        if comment:
            line += f"  # {comment}"
        lines.append(line)
    
    # Add differential pairs section
    diff_pairs = canonical_dict.get('differential_pairs', [])
    if diff_pairs:
        lines.extend([
            '',
            '# Differential pairs',
            '# These signals should be routed as differential pairs'
        ])
        
        for pair in diff_pairs:
            pos_net = pair.get('positive', '')
            neg_net = pair.get('negative', '')
            lines.append(f"# {pos_net} / {neg_net}")
    
    # Add metadata
    metadata = canonical_dict.get('metadata', {})
    if metadata:
        lines.extend([
            '',
            '# Pinmap metadata',
            f"# Total nets: {metadata.get('total_nets', 0)}",
            f"# Total pins: {metadata.get('total_pins', 0)}",
            f"# Differential pairs: {metadata.get('differential_pairs_count', 0)}",
        ])
        
        special_pins = metadata.get('special_pins_used', [])
        if special_pins:
            lines.append(f"# Special pins used: {', '.join(special_pins)}")
    
    return '\n'.join(lines) + '\n'


def _sanitize_identifier(name: str) -> str:
    """
    Convert net name to valid Python identifier.
    
    Args:
        name: Net name from schematic
        
    Returns:
        Valid Python identifier
    """
    # Replace invalid characters with underscores
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    
    # Ensure it starts with a letter or underscore
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    
    # Handle empty or invalid names
    if not sanitized or sanitized == '_':
        sanitized = 'UNNAMED_PIN'
    
    return sanitized.upper()


def _get_pin_comment(pin: str, canonical_dict: Dict[str, Any]) -> str:
    """
    Get descriptive comment for a pin.
    
    Args:
        pin: Pin name (e.g., 'GP24')
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Comment string
    """
    comments = [pin]  # Always include the pin name
    
    # Add special function information
    special_functions = {
        'GP24': 'USB D-',
        'GP25': 'USB D+', 
        'GP26': 'ADC0',
        'GP27': 'ADC1',
        'GP28': 'ADC2', 
        'GP29': 'ADC3',
        'GP23': 'SMPS_MODE'
    }
    
    if pin in special_functions:
        comments.append(special_functions[pin])
    
    return ' / '.join(comments)
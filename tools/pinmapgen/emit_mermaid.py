"""
Mermaid Diagram Emitter for PinmapGen.

Generates pinout.mmd Mermaid diagram files for visual documentation.
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Any


def emit_mermaid_diagram(canonical_dict: dict[str, Any], output_path: Path | str) -> None:
    """
    Generate Mermaid diagram file from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary with pins and differential pairs
        output_path: Path to output .mmd file
    """
    # Ensure we have a Path object
    if isinstance(output_path, str):
        output_path = Path(output_path)

    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)

    # Generate Mermaid diagram
    diagram = generate_mermaid_graph(canonical_dict)

    # Write to file
    with open(output_path, "w", encoding="utf-8") as f:
        f.write(diagram)


def generate_mermaid_graph(canonical_dict: dict[str, Any]) -> str:
    """
    Generate Mermaid graph syntax from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Mermaid diagram string
    """
    lines = []

    mcu = canonical_dict.get("mcu", "unknown").upper()
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Diagram header with metadata
    lines.extend([
        f"%% {mcu} Pinout Diagram",
        f"%% Generated by PinmapGen on {timestamp}",
        "",
        "graph TB",
        "    %% MCU node",
        f'    MCU["{mcu}<br/>Microcontroller"]',
        "",
    ])

    # Extract and sort pins
    pins = canonical_dict.get("pins", {})
    pin_data = []

    for net_name, pin_list in pins.items():
        if len(pin_list) == 1:  # Single pin nets only
            pin = pin_list[0]
            match = re.match(r"GP(\d+)", pin)
            if match:
                pin_num = int(match.group(1))
                pin_data.append((pin_num, net_name, pin))

    # Sort by pin number
    pin_data.sort(key=lambda x: x[0])

    # Define node styles and connections
    lines.extend([
        "    %% Pin nodes and connections",
    ])

    # Group pins by function for better layout
    pin_groups = _group_pins_by_function(pin_data, canonical_dict)

    # Generate nodes and connections for each group
    for group_name, group_pins in pin_groups.items():
        if group_pins:
            lines.append(f"    %% {group_name} pins")

            for pin_num, net_name, pin in group_pins:
                node_id = _sanitize_node_id(net_name)
                node_label = _create_node_label(net_name, pin, canonical_dict)
                node_style = _get_node_style(net_name, pin, canonical_dict)

                # Create connection from MCU to pin
                lines.append(f'    MCU --> {node_id}["{node_label}"]')

                # Add styling if needed
                if node_style:
                    lines.append(f"    class {node_id} {node_style}")

            lines.append("")

    # Add differential pair subgraphs
    diff_pairs = canonical_dict.get("differential_pairs", [])
    if diff_pairs:
        lines.extend([
            "    %% Differential pairs as subgraphs",
        ])

        for i, pair in enumerate(diff_pairs):
            pos_net = pair.get("positive", "")
            neg_net = pair.get("negative", "")

            pos_id = _sanitize_node_id(pos_net)
            neg_id = _sanitize_node_id(neg_net)

            # Determine signal type for subgraph name
            signal_type = _get_diff_signal_type(pos_net, neg_net)

            # Create subgraph for differential pair
            lines.extend([
                f'    subgraph DIFF{i}["{signal_type} Differential Pair"]',
                "        direction LR",
                f'        {pos_id} -.->|"differential"| {neg_id}',
                f'        {neg_id} -.->|"pair"| {pos_id}',
                "    end",
                ""
            ])

        lines.append("")

    # Define styles
    lines.extend([
        "    %% Node styling",
        "    classDef power fill:#ffeb3b,stroke:#f57f17,stroke-width:2px",
        "    classDef analog fill:#4caf50,stroke:#2e7d32,stroke-width:2px",
        "    classDef digital fill:#2196f3,stroke:#1565c0,stroke-width:2px",
        "    classDef special fill:#ff9800,stroke:#e65100,stroke-width:2px",
        "    classDef communication fill:#9c27b0,stroke:#6a1b9a,stroke-width:2px",
        "    classDef differential fill:#f44336,stroke:#c62828,stroke-width:3px",
        "",
        "    %% MCU styling",
        "    class MCU mcu",
        "    classDef mcu fill:#607d8b,stroke:#37474f,stroke-width:3px,color:#fff",
        ""
    ])

    return "\n".join(lines)


def _group_pins_by_function(pin_data: list[tuple], canonical_dict: dict[str, Any]) -> dict[str, list[tuple]]:
    """Group pins by their function for better diagram layout."""
    groups = {
        "Power": [],
        "Analog": [],
        "Communication": [],
        "Digital I/O": []
    }

    # Get differential pair net names to exclude them from groups
    diff_pair_nets = set()
    diff_pairs = canonical_dict.get("differential_pairs", [])
    for pair in diff_pairs:
        diff_pair_nets.add(pair.get("positive", ""))
        diff_pair_nets.add(pair.get("negative", ""))

    for pin_num, net_name, pin in pin_data:
        # Skip differential pair nets (they'll be in subgraphs)
        if net_name in diff_pair_nets:
            continue

        # Categorize by net name patterns
        net_upper = net_name.upper()

        if any(keyword in net_upper for keyword in ["VCC", "VDD", "GND", "POWER", "3V3", "5V"]):
            groups["Power"].append((pin_num, net_name, pin))
        elif any(keyword in net_upper for keyword in ["ADC", "ANALOG", "AIN"]) or pin in ["GP26", "GP27", "GP28", "GP29"]:
            groups["Analog"].append((pin_num, net_name, pin))
        elif any(keyword in net_upper for keyword in ["I2C", "SPI", "UART", "CAN", "SDA", "SCL", "MOSI", "MISO"]):
            groups["Communication"].append((pin_num, net_name, pin))
        else:
            groups["Digital I/O"].append((pin_num, net_name, pin))

    # Remove empty groups
    return {k: v for k, v in groups.items() if v}


def _sanitize_node_id(name: str) -> str:
    """Convert net name to valid Mermaid node ID."""
    # Replace invalid characters with underscores
    sanitized = re.sub(r"[^a-zA-Z0-9_]", "_", name)

    # Ensure it starts with a letter
    if sanitized and sanitized[0].isdigit():
        sanitized = "PIN_" + sanitized

    if not sanitized or sanitized == "_":
        sanitized = "UNNAMED_PIN"

    return sanitized


def _create_node_label(net_name: str, pin: str, canonical_dict: dict[str, Any]) -> str:
    """Create descriptive label for Mermaid node."""
    label_parts = [net_name, pin]

    # Add special function if applicable
    special_functions = {
        "GP24": "USB D-",
        "GP25": "USB D+",
        "GP26": "ADC0",
        "GP27": "ADC1",
        "GP28": "ADC2",
        "GP29": "ADC3",
        "GP23": "SMPS"
    }

    if pin in special_functions:
        label_parts.append(special_functions[pin])

    return "<br/>".join(label_parts)


def _get_node_style(net_name: str, pin: str, canonical_dict: dict[str, Any]) -> str:
    """Get CSS class name for node styling."""
    net_upper = net_name.upper()

    # Check if part of differential pair
    diff_pairs = canonical_dict.get("differential_pairs", [])
    for pair in diff_pairs:
        if net_name in [pair.get("positive"), pair.get("negative")]:
            return "differential"

    # Categorize by function
    if any(keyword in net_upper for keyword in ["VCC", "VDD", "GND", "POWER", "3V3", "5V"]):
        return "power"
    if any(keyword in net_upper for keyword in ["ADC", "ANALOG", "AIN"]) or pin in ["GP26", "GP27", "GP28", "GP29"]:
        return "analog"
    if any(keyword in net_upper for keyword in ["I2C", "SPI", "UART", "CAN", "SDA", "SCL", "MOSI", "MISO"]):
        return "communication"
    if pin in ["GP24", "GP25", "GP23"]:  # Special function pins
        return "special"
    return "digital"


def _get_diff_signal_type(pos_net: str, neg_net: str) -> str:
    """Get signal type name for differential pair."""
    # Check for common differential signal patterns
    for net in [pos_net, neg_net]:
        net_upper = net.upper()
        if "USB" in net_upper:
            return "USB"
        if "CAN" in net_upper:
            return "CAN"
        if "UART" in net_upper or "RS485" in net_upper:
            return "UART"
        if "ETH" in net_upper or "ETHERNET" in net_upper:
            return "Ethernet"

    # If no specific type found, use generic name
    return "Signal"

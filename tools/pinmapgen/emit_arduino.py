"""
Arduino C++ Header Emitter for PinmapGen.

Generates pinmap_arduino.h files for Arduino/PlatformIO projects.
"""

import re
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Any, Union


def emit_arduino_header(canonical_dict: Dict[str, Any], output_path: Union[Path, str]) -> None:
    """
    Generate Arduino C++ header file from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary with pins and differential pairs
        output_path: Path to output header file
    """
    # Ensure we have a Path object
    if isinstance(output_path, str):
        output_path = Path(output_path)
    
    # Create output directory if it doesn't exist
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Generate header code
    code = generate_arduino_defines(canonical_dict)
    
    # Write to file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(code)


def generate_arduino_defines(canonical_dict: Dict[str, Any]) -> str:
    """
    Generate Arduino #define statements from canonical dictionary.
    
    Args:
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        C++ header code string
    """
    lines = []
    
    # Header guard name based on filename
    guard_name = "PINMAP_ARDUINO_H"
    mcu = canonical_dict.get('mcu', 'unknown').upper()
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # File header with include guard
    lines.extend([
        '// Auto-generated pinmap for ' + mcu,
        '// Generated by PinmapGen',
        f'// Timestamp: {timestamp}',
        '//',
        '// Usage:',
        '//   #include "pinmap_arduino.h"',
        '//   pinMode(LED_DATA, OUTPUT);',
        '//   digitalRead(BUTTON);',
        '',
        f'#ifndef {guard_name}',
        f'#define {guard_name}',
        '',
    ])
    
    # Extract pins and sort by pin number for consistent output
    pins = canonical_dict.get('pins', {})
    pin_definitions = []
    
    for net_name, pin_list in pins.items():
        if len(pin_list) == 1:  # Single pin nets only
            pin = pin_list[0]
            # Extract pin number (GP0 -> 0)
            match = re.match(r'GP(\d+)', pin)
            if match:
                pin_num = int(match.group(1))
                # Create valid C identifier from net name
                const_name = _sanitize_c_identifier(net_name)
                
                # Add special pin comments
                comment = _get_pin_comment(pin, canonical_dict)
                
                pin_definitions.append((pin_num, const_name, pin_num, comment))
    
    # Sort by pin number
    pin_definitions.sort(key=lambda x: x[0])
    
    # Generate #define statements
    max_name_len = max(len(name) for _, name, _, _ in pin_definitions) if pin_definitions else 0
    
    lines.append('// Pin definitions')
    for _, const_name, pin_num, comment in pin_definitions:
        line = f"#define {const_name.ljust(max_name_len)} {pin_num}"
        if comment:
            line += f"  // {comment}"
        lines.append(line)
    
    # Add differential pairs section
    diff_pairs = canonical_dict.get('differential_pairs', [])
    if diff_pairs:
        lines.extend([
            '',
            '// Differential pairs',
            '// These signals should be routed as differential pairs'
        ])
        
        for pair in diff_pairs:
            pos_net = pair.get('positive', '')
            neg_net = pair.get('negative', '')
            lines.append(f"// {pos_net} / {neg_net}")
    
    # Add helper macros
    lines.extend([
        '',
        '// Helper macros',
        '#define PIN_COUNT ' + str(len(pin_definitions)),
        '#define MCU_TYPE "' + mcu + '"',
    ])
    
    # Add metadata as comments
    metadata = canonical_dict.get('metadata', {})
    if metadata:
        lines.extend([
            '',
            '// Pinmap metadata',
            f"// Total nets: {metadata.get('total_nets', 0)}",
            f"// Total pins: {metadata.get('total_pins', 0)}",
            f"// Differential pairs: {metadata.get('differential_pairs_count', 0)}",
        ])
        
        special_pins = metadata.get('special_pins_used', [])
        if special_pins:
            lines.append(f"// Special pins used: {', '.join(special_pins)}")
    
    # Close header guard
    lines.extend([
        '',
        f'#endif // {guard_name}',
        ''
    ])
    
    return '\n'.join(lines)


def _sanitize_c_identifier(name: str) -> str:
    """
    Convert net name to valid C identifier.
    
    Args:
        name: Net name from schematic
        
    Returns:
        Valid C identifier
    """
    # Replace invalid characters with underscores
    sanitized = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    
    # Ensure it starts with a letter or underscore
    if sanitized and sanitized[0].isdigit():
        sanitized = '_' + sanitized
    
    # Handle empty or invalid names
    if not sanitized or sanitized == '_':
        sanitized = 'UNNAMED_PIN'
    
    return sanitized.upper()


def _get_pin_comment(pin: str, canonical_dict: Dict[str, Any]) -> str:
    """
    Get descriptive comment for a pin.
    
    Args:
        pin: Pin name (e.g., 'GP24')
        canonical_dict: Canonical pinmap dictionary
        
    Returns:
        Comment string
    """
    comments = [pin]  # Always include the pin name
    
    # Add special function information
    special_functions = {
        'GP24': 'USB D-',
        'GP25': 'USB D+', 
        'GP26': 'ADC0',
        'GP27': 'ADC1',
        'GP28': 'ADC2', 
        'GP29': 'ADC3',
        'GP23': 'SMPS_MODE'
    }
    
    if pin in special_functions:
        comments.append(special_functions[pin])
    
    return ' / '.join(comments)